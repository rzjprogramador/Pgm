# dart
pagina_oficial: www.dart.dev

como_atualizar_ferramenta: [ { no_linux: , tutorial: https://stackoverflow.com/questions/65602656/the-current-dart-sdk-version-is-2-10-4-how-can-i-change-the-version-into-a-uppe, }],

doc_tipos : [ https://dart.dev/language/built-in-types , https://www.devmedia.com.br/sintaxe-dart-tipos-nao-tao-primitivos/40368 ]

comando_saida: [ { imprimir_no_console: "print( alvo )", }]

pensamento_sempre_antes_de_declarar_uma_referencia: "pense o TIPO do valor que será guardado nesta variavel o NOME e a OPERACAO que fará ex: atribuicao, preparar algo é dentro escopo {}, operacoes conforme o tipo do valor permite.",

valores_zero_por_default: "na maioria das linguagens o valor default é zerado o primeiro valor que se pode dar a um tipo, ex: de string é string vazia, de numero é zero, de logico é false. Mas tem inguagem que inicia com null todos tipos de referencia por exemplo dart é assim. Em dart para permitir que uma referencia possa nao receber valor tem que demarcar com ? possivel nulo o tipoQueRetornará e se nada for preenchido o valor zero de todos os tipos posssiveis nulos é nulo / null por isto apra usar tem que verificar se é nulo ou nao antes de fazer algo"

sem_valor_NULO : { valor_default: null, representacaoValida: }

permitir_nao_ter_valor_valido_NULO : inserir depois da keyword Tipo uma interrogacao, exemplo: String?,
tipar_retorno_possivel_NULO:
      resposta: é o mesmo da assinatura o tipo e interrogacao :: Tipo?,
      exemplo:  String? podeSerNulo() {}

tipo_para_demarcacao: {
      demarca_referencia_para_ser_inferida_ter_tipo_conforme_preenchimento: {
        keyword: "var", detalhes: "deixa a referencia inferida para receber qualquer tipo, reatribuivel poder receber outra atribuicao, após a primeira atribuicao nao da pra trocar o tipo, acessa os membros do tipo, mas não é recomendado #naoBoaPratica porque em materia de legibilidade nao mostra explicitamente o tipo que ela vai receber. Use em caso de precisar usar referencias externas ex: variavel, objeto de servidor, coisas externas que ainda nao sabe o tipo e quando descobrir corrija e pare de usar coloque o tipo correto . O correto mesmo é declarar sempre o tipo valido que recebera a referencia.",
      },
      dinamica_recebe_qualquer_tipo_estilo_ANY: {
        keyword: "dynamic",
        detalhes: "Pode assumir qualquer tipo de valor, ser atribuida depois após a declaracao, é o estilo ANY aceita qualquer tipo como preenchimento, não é recomendada #naoBoaPratica use somente em casos especificos, sempre prefira assinalar qual o tipo do preenchimento, este recurso estilo any tem que ser exporadico de vez em quando quando nao tem jeito. Use em caso de precisar usar referencias externas ex: variavel, objeto de servidor, coisas externas que ainda nao sabe o tipo e quando descobrir corrija e pare de usar coloque o tipo correto. Use em caso de precisar usar referencias externas ex: variavel, objeto de servidor, coisas externas que ainda nao sabe o tipo e quando descobrir corrija e pare de usar coloque o tipo correto . O correto mesmo é declarar sempre o tipo valido que recebera a referencia.",
      },

      demarca_pode_ser_nulo: "?",
      demarca_afirmo_que_tera_valor_nunca_sera_nulo_confia: "#naoTEM"

    }

    tipos_para_numeros: {
        numero_inteiro: int,
        numero_decimal: double,
        numero_inteiro_ou_decimal: num,
        somente_numeros_positivos: #naoTEM,
      }

valores_padroes_por_default: {
  parametro_com_valor_default: { sintaxe: { referencia = "valor" }, detalhes: "em dart o parametro default tem que estar dentro de chaves e é atribuido com sinal de igual =" }
}

funcao_palavra_chave_para_funcao: não tem :: usa o tipoRetornado_nome_valor,

palavra_chave_ternario: não precisa faz a condicao direto,
sintaxe_ternario: Tipo resultado = (alvo LOGICA) ? retornoCaso_TRUE_ACondicao : retornoCaso_FALSE_ACondicao;

exemplo:
  int resultadoNumerico = (naoTeraValor_NULO == null) ? naoTeraValor_NULO = 0 : naoTeraValor_NULO += 100;

tipo_Data: DateTime ,
