# TODA LINGUAGEM TEM

nome,
retentora,
plataforma,
pagina_oficial,

como_atualizar_ferramenta: [ { no_linux: , tutorial: , }],

pode_fazer: [ { ferramenta, habilitado, } ]
extensao,

comando_saida: [ { imprimir_no_console, }]

forma_de_debugar: { no_console, no_debugger }

sintaxe: {
  obrigatorios: { ponto_virgula_sentencas, virgula_ultimo_campo_objeto, aspas_duplas_texto, },
  assinaturas: {
    assinalar: ao assinalar que a referencia sera de um tipo, voce esta dizendo que ela vai retornar um valor que representar este tipo.
    referencia_informacao_Unitaria: tipoRetornado_nome_valor
    funcao_palavra_chave_para_funcao: ,
    funcao: tipoRetornado_nome_valor
    metodo: tipoRetornado_nome_valor

    }
}

informacao_Unitaria :
  tipos: {
    conceito: "o tipo de uma referencia é importante para poder usar os membros(variavel ou metodo) de operações possiveis conforme o tipo do dado guardado na referencia.",

    pensamento_sempre_antes_de_declarar_uma_referencia: "pense o TIPO do valor que será guardado nesta variavel o NOME e a OPERACAO que fará ex: atribuicao, preparar algo é dentro escopo {}, operacoes conforme o tipo do valor permite.",

    valores_zero_por_default: "na maioria das linguagens o valor default é zerado o primeiro valor que se pode dar a um tipo, ex: de string é string vazia, de numero é zero, de logico é false. Mas tem inguagem que inicia com null todos tipos de referencia por exemplo dart é assim.",

    tipos_primitivos : {
      conceito,
      doc_tipos: [],
      caractere_unico:
      texto: { valor_default: , representacaoValida: }
      logico,
      objeto,
      registro,
      conjuntos,
      colecoes,
      },
    tipos_nao_primitivos
    conceito: A maioria dos tipos Nao primitivos validos são objetos e poderemos usar os membros metodos desencadeados ao assinalar nossa referencia sendo deste tipo.,
    sem_valor_NULO : {
      valor_default: ,
      representacaoValida: ,

      conceito: "permitir_nao_ter_valor_valido_NULO, voce pode explicitar que sera nulo ex: int num = null <MAs isto nao é legal e pode nao compilar porque voce disse que é um int>, uso: tudo que permitimos ser NULO para usar temos que verificar se não é nulo" senão verificar o compilador nao deixa realizar nenhuma operacao ou preencher valor com o que pode ser nulo porque se voce chamar algo que é nulo vai crachar quebrar o programa, por isto tem que verificar e se for nulo amortizar o problema,
      depois de especificar no tipo que podera ser nulo voce NÃO podera fazer operacões (incrementar, somar com algo, tudo só podera atribuir preencher com valor ai sim fica liberada porque tera um valor do tipo especificado) então um possivel nulo voce só pode reatribuir preencher valor ou checar e depois de checado fazer algo(operacoes) , resumo: tipo nulo podera nao receber um valor, tem que demarcar com o ? colado depois do tipo e quando for usar verificar se não é nulo a referencia.,

      nao_permitir_ser_nulo: "nao marque no tipo que podera ser nulo"

      tipar_retorno_possivel_NULO:
        resposta: ,
        exemplo:

      exemplo: ,
      verificar_se_tem_valor_NAO_e_NULO:
    },

    tipo_Data: ,

    tipo_para_demarcacao: {
      demarca_referencia_para_ser_inferida_e_ser_mutavel_regravavel_reatribuida: {
        keyword: "",
        detalhes: "deixa a referencia inferida para receber qualquer tipo, reatribuivel poder receber outra atribuicao, após a primeira atribuicao nao da pra trocar o tipo, acessa os membros do tipo, mas não é recomendado #naoBoaPratica porque em materia de legibilidade nao mostra explicitamente o tipo que ela vai receber. Use em caso de precisar usar referencias externas ex: variavel, objeto de servidor, coisas externas que ainda nao sabe o tipo e quando descobrir corrija e pare de usar coloque o tipo correto . O correto mesmo é declarar sempre o tipo valido que recebera a referencia.",
      },
      dinamica_recebe_qualquer_tipo_estilo_ANY: {
        keyword: "",
        detalhes: "Pode assumir qualquer tipo de valor, ser atribuida depois após a declaracao, é o estilo ANY aceita qualquer tipo como preenchimento, posso alterar o tipo do dado tambem ex: se foi preenchido com string depois posso atribuir com numero, não é recomendada #naoBoaPratica use somente em casos especificos quando ainda nao sei qual será seu tipo de dado a ser guardado, o contra é que não permite usar na referencia os membros prototipos do tipo do dado guardado, sempre prefira assinalar qual o tipo do preenchimento, este recurso estilo any tem que ser exporadico de vez em quando quando nao tem jeito. Use em caso de precisar usar referencias externas ex: variavel, objeto de servidor, coisas externas que ainda nao sabe o tipo e quando descobrir corrija e pare de usar coloque o tipo correto . O correto mesmo é declarar sempre o tipo valido que recebera a referencia.",
      },

      demarca_pode_ser_nulo,
      demarca_afirmo_que_tera_valor_nunca_sera_nulo_confia,

      tipos_para_numeros: {
        numero_inteiro: ,
        numero_decimal: ,
        numero_inteiro_ou_decimal: ,
        somente_numeros_positivos:
      }
    }

  tipos_personalizados_estruturado {
    conceito,
    estrutura_para_cria_tipo,
    }

===

valores_padroes_por_default: {
  parametro_com_valor_default: { sintaxe, detalhes }
}

ferramentas_funcoes:
  tomada_decisao:
    ternario:
      conceito: faz a logica da condicao ? se der true a condicao faz isto : senao faz isto // obs: um ternario resulta em um valor então o seu resultado tem que ser guardado numa referencia de resultado,
      palavra_chave_ternario: ,
      sintaxe_ternario,
      exemplo: ,


forma_de_fazer_contrato: "",
forma_criar_instancia_objeto: ""

